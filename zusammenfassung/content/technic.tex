
\section{Technische Aspekte}
Im vorherigen Kapitel haben sich als wichtige Anforderungen an den Rechtsverkehr und die elektronische Dokumente heraus kristallisiert:
\begin{itemize}
\item Authentizität und Integrität
\item Vertraulichkeit
\item Datenschutz persönlicher Daten
\end{itemize}
Um diese Anforderungen auf technische Ebene zu gewährleisten werden verschiedene Verfahren und Konzepte der Authentifizierung, Autorisierung und zur Erstellung von digitalen Signaturen eingesetzt. Im folgenden sollen gängige Verfahren vorgestellt werden um den notwendigen  technischen Hintergrund zu schaffen. 
\subsection*{Authentifizierung}
Es existieren viele verschiedene Authentifizierungsverfahren, welche sich in ihrer Komplexität unterscheiden. Die einfachsten Verfahren erwarten die Eingabe von Benutzername und Passwort. Allerdings gehören diese auch zu den unsichersten Verfahren. Damit eine Authentifizierung möglich ist, müssen eindeutige die Person identifizierende Eingaben vorliegen. Diese lassen sich in drei Kategorien unterscheiden.
\begin{itemize}
\item Wissen: Eingabe einer geheimen Information, beispielsweise ein PIN.
\item Gegenstand: Auslesen eines Gegenstandes,z.B. eine Karte oder ein USB-Token
\item Attribut: Ein Indentifikationsmerkmal der Person, beispielsweise das Augenmuster oder der Fingerabdruck eines Menschen.
\end{itemize}
\subsubsection{Multi-factor authentication}
Je nach Authentifizierungsverfahren reicht die Eingabe einer Information (Single Factor Authentication) oder es müssen mehrere Faktoren eingegeben werden (Multi Factor Authentication).
Dabei kann jeder Faktor die Person eindeutig identifizieren. Damit eine Authentifizierung erfolgreich ist müssen jedoch alle Eingaben korrekt sein. Bei der Multi Factor Authentication werden aus Sicherheitsgründen Faktoren aus unterschiedlichen Kategorien gewählt. Ein typisches Beispiel ist die Authentifizierung an einem Bankautomat. Dazu ist die Eingabe eines PINS, sowie einer Bankkarte notwendig. Nur wenn beide Faktoren vorliegen und zueinander passen ist die Authentifizierung erfolgreich. 
\subsubsection{Mutual authentication}
erlaubt dem Benutzer zu verifizieren, dass die Authentifizierung an dem gewünschten System erfolgreich war, sodass er nur nach einer erfolgreichen Authentifizierung seine sicherheitskritischen Daten ein gibt. \textit{Phishing Attacks} zielen darauf ab, Benutzern eine Authentifizierung  vorzutäuschen, sodass sie danach z.B. ihr Passwort eingeben, obwohl sie nicht mit dem gewünschten System verbunden sind.


\subsubsection{Shared Secrets (Passwords)}
\textit{Shared Secrets} wie Passwörter oder PINS sind die meist genutzten Schlüssel um Sicherheit zu gewährleisten und Zugriff auf Online Portale erlauben. Ein Problem dabei ist jedoch, dass die Erfahrung gezeigt hat, dass Menschen dazu neigen schlechte Passwörter zu wählen, sie leicht offen legen, oder ihre Passwörter vergessen. Dies macht es einfach für einen Spezialisten das Passwort zu stehlen. 
\subsubsection{One time passwords (otp)}
Ein \textit{One time password} ist ein Passwort, welches sich für jede Verwendung ändert. Es werden zwei grundlegende Möglichkeiten unterschieden, wie ein \textit{One time password} funktioniert:
\begin{itemize}
\item Es wird eine Liste von Tans generiert, die zwischen dem Benutzer und System geteilt wird. Bei jeder Verwendung wird der Benutzer nach einer der Tans gefragt.
\item Bei jeder Passworteingabe wird das Passwort vom Benutzer neu generiert und vom System verifiziert. Dabei kann das Passwort z.B. eine Funktion von der aktuellen Zeit sein, welches der Benutzer und das System teilen.
\end{itemize}
\subsubsection{SSL/TLS Protokoll}
SSL/TLS sind Protokolle, die für den sicheren Austausch von Informationen zwischen Client und Server genutzt werden. Im folgenden wird kurz der Vorgang eines \textit{SSL Handshake} unter Nutzung des \textit{RSA exchange} Algorithmus beschrieben:
\begin{enumerate}
\item \textit{Client Hello:} Der Client sendet für die SSL Kommunikation notwendige Informationen wie z.B. die SSL Version.
\item \textit{Server Hello:} Der Server antwortet mit für den Client relevanten Informationen, u.a. mit dem SSl Zertifikat des Servers (Public Key).
\item  Der Client überprüft das Zertifikat auf Korrektheit.  Ist dies gegeben, erzeugt der Client den Schlüssel für die spätere Kommunikation und verschlüsselt ihn mit dem \textit{Public Key} des Servers.
\item Der Server entschlüsselt den Schlüssel mit dem Private Key.
\item Für die Session wird der Session Schlüssel zur Verschlüsselung der Kommunikation genutzt.
\end{enumerate}	
\subsection*{Autorisierung/Zugriffskontrolle}

Der Sinn und Zweck von Zugriffskontrolle ist die erlaubten Operationen auf einen Datensatz einzuschränken. In der Informatik beschränken Zugangsberechtigungen sowohl die erlaubten Operationen eines Nutzers als auch die eines Programms. In diesem Sinne soll Zugriffskontrolle alle Operationen, welche die Sicherheit einschränken, verhindern. Im folgenden werden verschiedene Grundsätze der Zugriffskontrolle beschrieben.

\subsubsection{Voraussetzung}
Damit Zugriffskontrolle möglich ist, muss das System den Benutzer erkennen. Dies bedeutet, dass sich der Benutzer in einem ersten Schritt in dem System anmelden muss(vgl. Authentifizierung). Vor jeder Anfrage muss erneut überprüft werden, ob der Benutzer die nötigen Berechtigungen besitzt.
\subsubsection{Zugriffssteuerungsmatrix}
Die Zugriffssteuerungsmatrix ist ein abstraktes Sicherheitskonzept, welches jedem Benutzer zu jedem Objekt gewisse Rechte zuweist. Das bedeutet insbesondere, dass für jedes Objekt unterschiedliche Berechtigungen gelten können. Es wurde 1971 von Butler W. Lampson eingeführt(Quelle).
\subsubsection{Rollenbasierte Zugriffskontrolle}
Role Based Access Control (RBAC; deutsch: Rollenbasierte Zugriffskontrolle) ist in Mehrbenutzersystemen oder Rechnernetzen ein Verfahren zur Zugriffssteuerung und -kontrolle auf Dateien oder Dienste. Das RBAC-Modell wurde 1992 von D.F. Ferraiolo und D.R. Kuhn beschrieben[1] und 2004 als ANSI-Norm 359-2004 verabschiedet.
\\\\
Die alternative Methode, einem realen Benutzer (User) direkt Rechte und Zugriffe auf verschiedene Systeme zu geben, stellte sich durch die steigende Zahl von Benutzern als unübersichtlich und daher fehlerträchtig dar. Das auf Benutzerrollen basierende Konzept soll nun die Rechte anhand von Arbeitsprozessen abstrahieren.
\\\\
Bei der rollenbasierten Zugriffskontrolle werden den Benutzern des Computers oder Netzwerks Rollen zugeordnet. Benutzer können dabei mehrere Benutzerrollen besitzen. An eine Rolle sind beispielsweise 1 bis n Gruppenzugehörigkeiten gebunden. Je nach Rollenzuordnung des Benutzers (und den damit verbundenen Gruppenzugehörigkeiten) erteilt oder sperrt das System dann das Zugriffsrecht auf Betriebsmittel. Häufig werden vor allem Lesen, Schreiben und Ausführen von Dateien mittels RBAC kontrolliert; das Verfahren ist jedoch nicht darauf beschränkt.

\subsubsection{Militär Sicherheitsbestimmung}
Das Prinzip der Militär Sicherheitsbestimmung ist es Informationen basierend auf ihrer Sicherheitsstufe zu klassifizieren. Es wird unterschieden zwischen
\begin{itemize}
\item unclassified
\item restricted
\item confidential
\item secret 
\item topsecret
\end{itemize} 
Jeder Information ist ein Tupel aus Rang und Kompartiment zugeordnet. Dabei bestimmt das Kompartment zu welchen Projekten die Information gehört. 
Eine Person kann auf Informationen bis zu einer gewissen Sicherheitsstufe zugreifen. Die Zugangsberechtigung einer Person wird ebenfalls als Tupel aus Rang und Kompartiment dargestellt.   
\subsubsection{Bell-LaPdula Modell}
Das \textit{Bell-LaPdula Modell} ähnelt dem \textit{Military security policy}. Zusätzlich werden unterschiedliche Schreib- und Leserechte definiert. Insbesondere kann kein Datensatz höherer Sicherheitsstufe gelesen und kein Datensatz mit niedriger Sicherheitsstufe geschrieben/bearbeitet werden.
\subsubsection{Conditional Policies}
\textit{Conditional Policies} bedeutet, dass Sicherheitskriterien zusätzlich zu den bereits genannten Punkten auch abhängig von dem aktuellen Kontext des Benutzers sein können. Beispielsweise kann der Zugang zu speziellen Daten, nur von einem bestimmten Ort und auch nur für einen gewissen Zeitraum freigeschaltet werden.
\subsubsection{Biba Modell}
Das \textit{Biba Model} dient der Wahrung der Integrität. Es beinhaltet das Daten einer niedrigeren Sicherheitsstufe wie der Benutzer nicht gelesen und Daten einer höheren Sicherheitsstufe nicht geschrieben werden dürfen. Es ist damit eine Umkehrung des \textit{Bell-LaPdula Modells}.
\subsubsection{Separation of duty}
Das Prinzip \textit{Separation of duty} besagt, dass für eine wichtige Aufgabe immer mehr als eine Person verantwortlich sind. Dies beinhaltet das wichtige Entscheidungen nur unter Zustimmung aller Verantwortlichen getroffen werden dürfen. Dadurch sollen sowohl Fehler als auch Machtmissbrauch verhindert werden
\subsubsection{Chinese Wall Policy}
Nach dem \textit{Chinese Wall Policy} darf ein Benutzer nur auf Daten zugreifen, die nicht im Konflikt mit anderen Daten stehen, welche dem Benutzer zur Verfügung stehen. Dadurch soll ein Interessenkonflikt des Benutzers vermieden werden. 
\subsubsection{Principle of Least Privilege}
Das \textit{Principle of Least Privilege} besagt, dass Personen nur auf diejenigen Daten zugreifen dürfen, die für ihre Arbeit zwingend erforderlich sind.
\subsection*{Digitale Signaturen}
Eine digitale Signatur, auch digitales Signaturverfahren, ist ein asymmetrisches Kryptosystem, bei dem ein Sender mit Hilfe eines geheimen Signaturschlüssels (dem Private Key) zu einer digitalen Nachricht (d. h. zu beliebigen Daten) einen Wert berechnet, der ebenfalls digitale Signatur genannt wird. Dieser Wert ermöglicht es jedem, mit Hilfe des öffentlichen Verifikationsschlüssels (dem Public Key) die nichtabstreitbare Urheberschaft und Integrität der Nachricht zu prüfen. Um eine mit einem Signaturschlüssel erstellte Signatur einer Person zuordnen zu können, muss der zugehörige Verifikationsschlüssel dieser Person zweifelsfrei zugeordnet sein.

Mit digitalen Signaturen lassen sich sichere elektronische Signaturen (fortgeschrittene elektronische Signaturen gem. § 2 Nr. 2 SigG bzw. qualifizierte elektronische Signaturen gem. § 2 Nr. 3 SigG) erzeugen. Die Begriffe digitale Signatur und elektronische Signatur sind jedoch nicht inhaltsgleich: Erstens müssen (zumindest fortgeschrittene) elektronische Signaturen nicht zwangsläufig auf digitalen Signaturen basieren; zweitens ist digitale Signatur ein mathematischer bzw. technischer Begriff, während elektronische Signatur ein juristischer Begriff ist.
\subsubsection{Gesetzliche Normen}
Die Bundesnetzagentur veröffentlicht jedes Jahr eine Liste mit Mindestanforderungen für kryptographische Algorithmen für die Erzeugung qualifizierter elektronischer Signaturen.[2] In der „Bekanntmachung zur elektronischen Signatur nach dem Signaturgesetz und der Signaturverordnung“ vom 18. Januar 2012 werden als geeignete digitale Signaturverfahren RSA , DSA und DSA-Varianten die auf elliptischen Kurven basierend (z. B. EC-DSA, EC-KDSA, EC-GDSA) empfohlen. Zu jedem dieser Verfahren werden die Mindestlängen für die Schlüssel sowie weitere Anforderungen an die Parameter und die Hashfunktion angegeben. [3]
\subsubsection{RSA}
In der modernen Kryptologie hat sich die RSA – Verschlüsslung als eine der
sichersten Methoden durchgesetzt. Sie wird heute in wichtigen Bereichen wie  im
Bankenwesen (z.B. bei der Verschlüsslung von Geheimzahlen) eingesetzt.
\\\\
Leonard Euler entdeckte eine mathematische Regel, die für die RSA –
Verschlüsselung grundlegend ist. Wählt man zwei positive Primzahlen $p$ und $q$ mit $p \neq q$, dann gilt:
\begin{equation}
	\begin{split}
		m^{s(p-1)(q-1)}\mod n = m
 	\end{split}
\end{equation}

$m,n \in \mathbb N $ mit $n<=n$ \\
Das heißt also, wenn man die Potenz $m^{s(p-1)(q-1)}$
durch $n$ teilt, so erhält man als Rest dieser Division wieder die Basis m. Diese Gültigkeit ist grundlegend für die Verschlüsselung mit dem RSA – Verfahren (siehe Abschnitt 3).
\\\\
Wollen zwei Teilnehmer sich gegenseitig eine Nachricht senden, welche für die
Öffentlichkeit geheim bleiben soll, die also nur von den beiden entschlüsselt werden
können soll, so müssen diese zuerst einige Schlüssel festlegen. Zunächst erhält
jeder Teilnehmer zwei große, voneinander verschiedene Primzahlen $p$ und $q$. Je
größer $p$ und $q$ sind, desto schwieriger ist die verschlüsselte Nachricht zu knacken.
Das Produkt $n$ der beiden Primzahlen ($n = pq$) kann als öffentlicher Schlüssel
verwendet werden. Das heißt, dieser kann unverschlüsselt und in aller Öffentlichkeit
ausgetauscht werden, ohne dass eine Entschlüsselung einfacher wird. 
Die Teilnehmer suchen nun nach einer Zahl $e \in \mathbb{N}$ die teilerfremend von der Zahl
$(p-1)*(q-1)$ ist, das heißt (p-1)*(q-1) und e haben außer 1 keine gemeinsamen Teiler.
Dies ist durch einfaches Probieren schnell herauszufinden. Auch die Zahl e kann im
Endeffekt als öffentlicher Schlüssel verwendet werden. Ebenfalls einfach ist es , eine Zahl $ d \in \mathbb{N}$ zu finden, für die gilt:
\begin{equation}
	\begin{split}
	e*d = s (p-1) (q-1) + 1 
 	\end{split}
\end{equation}

$s \in \mathbb{N}$
\\
Dabei kann die Zahl $s$ so gewählt werden, wie es für $d$ am besten passt, $s$ ist also
eine beliebige natürliche Zahl. Nun kann d als geheimer Schlüssel verwendet
werden. Entscheidend an dieser Formel ist, dass es einfach für einen Spion ist $d$ zu
bestimmen, wenn er $e$, $p$ und $q$ kennt. Es ist aber, vor allem bei großen $p$ und $q$,
nahezu unmöglich nur durch Kenntnis der öffentlichen Schlüssel $n$ und $e$ den
geheimen Schlüssel $d$ herauszufinden.
\subsubsection{DSA}:
wurde von NIST entwickelt und eignet sich speziell für Signaturen. Es ist eine Modifizierte Form des ELGamal Kryptographiesystems und basiert auf dem Problem der Diskreten Logarithmen. 
\textit{Schlüsselerzeugung:} 
\begin{enumerate}
\item Erzeuge eine Primzahl $p$ der Länge $512-1024$ Bit, sodass das Diskrete
Logarithmen Problem in $Z_p$ schwer ist
\item Erzeuge eine Primzahl q mit der Länge 160 Bit und q | (p-1)
\item Wähle ein $a \in Z_p$ das eine $q$ te Wurzel von $1 \mod p$ ist, d.h. es gelte
$a^q = 1 (\mod p)$.
\item Schlüsselmenge $K$ des DSA ist:

\end{enumerate}
\begin{equation}
	\begin{split}
		K=(p,q,a,b) :b=a^q \mod p,     0<=a<=q-1
 	\end{split}
\end{equation}
	
Wobei die Werte $p, q$ und $b$ den öffentlichen Schlüssel bilden und
$a$ der private Schlüssel ist
\\\\
\textit{Signieren:} 
\\\\
Für $x \in \{0,1\}^*, K = (p, q,  a, b)$ und eine (geheime) Zufallszahl $k: 1<=k<= q-1$
definieren wir die Signatur:
\\\\
\begin{equation}
	\begin{split}
		sig_K(x,k)=(y,d)-    mit	\\	
	y=(a^k \mod p) \mod q \\
			d=(SHA-1(x)+a*y)k^{-1} \mod q 
 	\end{split}
\end{equation}
Wenn $y = 0$ oder $d = 0$, wähle ein neues $k$	
\\\\
\textit{Verifizieren:}
\\\\
Für $x \in {0,1}^*$ und $(y, d) \in Z_p * Z_p$ , muss die Verifikation folgende
Berechnungen durchführen:
\begin{equation}
\begin{split}
		e1 = SHA-1(x) d^{–1} \mod q	\\	
		e2 = y*d^{-1} \mod q \\
			ver_K(x, (y,d)) = true <=> (a^{e1}*b^{e2} \mod p) \mod q = y 
\end{split}
\end{equation}